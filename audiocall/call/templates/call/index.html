{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiveKit Audio Call</title>
    <script src="{% static 'js/livekit-client.js' %}"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
        #audio-container { margin-top: 20px; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; }
        #error { color: red; }
        #room-info { margin-top: 20px; }
        #participants { list-style: none; padding: 0; }
        #participants li { margin: 5px 0; }
        .muted { color: gray; }
    </style>
</head>
<body>
    <h1>LiveKit Audio Call</h1>
    <input type="text" id="roomName" placeholder="Enter room name" value="audio-room">
    <input type="text" id="participantName" placeholder="Enter your name" value="user">
    <button onclick="joinRoom()">Join Audio Call</button>
    <button onclick="leaveRoom()" disabled>Leave Call</button>
    <button onclick="toggleMute()" disabled id="muteButton">Mute</button>
    <div id="audio-container"></div>
    <div id="error"></div>
    <div id="room-info">
        <h3>Active Room: <span id="active-room">None</span></h3>
        <h3>Participants:</h3>
        <ul id="participants"></ul>
    </div>

    <script>
        let room = null;
        let isMuted = false;

        // Update participants list with audio status
        const updateParticipants = () => {
            const participantsList = document.getElementById('participants');
            participantsList.innerHTML = '';
            const participants = (room && room.getParticipants) ? room.getParticipants() : [];
            participants.forEach(participant => {
                const li = document.createElement('li');
                const tracks = participant.getTrackPublications ? Array.from(participant.getTrackPublications()) : [];
                const isAudioMuted = tracks.length === 0 || tracks.every(track => track.isMuted);
                li.innerText = `${participant.identity}${isAudioMuted ? ' (Muted)' : ''}`;
                if (isAudioMuted) li.classList.add('muted');
                participantsList.appendChild(li);
                console.log(`Participant in UI: ${participant.identity}, SID: ${participant.sid}, muted: ${isAudioMuted}, tracks: ${tracks.length}, trackSIDs: ${tracks.map(t => t.trackSid).join(', ')}`);
            });
            if (room && room.localParticipant) {
                const localLi = document.createElement('li');
                const localTracks = room.localParticipant.getTrackPublications ? Array.from(room.localParticipant.getTrackPublications()) : [];
                const localAudioMuted = localTracks.length === 0 || localTracks.every(track => track.isMuted);
                localLi.innerText = `${room.localParticipant.identity} (You)${localAudioMuted ? ' (Muted)' : ''}`;
                if (localAudioMuted) localLi.classList.add('muted');
                participantsList.appendChild(localLi);
                console.log(`Local participant in UI: ${room.localParticipant.identity}, muted: ${localAudioMuted}, tracks: ${localTracks.length}, trackSIDs: ${localTracks.map(t => t.trackSid).join(', ')}`);
            }
        };

        // Attach audio tracks for a participant
        const attachAudioTracks = (participant) => {
            const tracks = participant.getTrackPublications ? Array.from(participant.getTrackPublications()) : [];
            if (tracks.length > 0) {
                tracks.forEach(publication => {
                    if (publication.kind === 'audio' && publication.track && !publication.isMuted && !document.getElementById(`audio-${participant.sid}-${publication.trackSid}`)) {
                        const audioElement = publication.track.attach();
                        audioElement.id = `audio-${participant.sid}-${publication.trackSid}`;
                        document.getElementById('audio-container').appendChild(audioElement);
                        audioElement.play().catch(err => console.error(`Failed to play audio for ${participant.identity}, trackSid: ${publication.trackSid}:`, err));
                        console.log(`Attached audio track for ${participant.identity}, trackSid: ${publication.trackSid}`);
                    } else {
                        console.log(`Skipping attachment for ${participant.identity}, trackSid: ${publication.trackSid}, kind: ${publication.kind}, isMuted: ${publication.isMuted}, already attached: ${!!document.getElementById(`audio-${participant.sid}-${publication.trackSid}`)}`);
                    }
                });
            } else {
                console.log(`No audio tracks to attach for ${participant ? participant.identity : 'unknown'}, tracks: ${tracks.length}`);
            }
        };

        // Detach audio tracks for a participant
        const detachAudioTracks = (participant) => {
            const tracks = participant.getTrackPublications ? Array.from(participant.getTrackPublications()) : [];
            tracks.forEach(publication => {
                const audioElement = document.getElementById(`audio-${participant.sid}-${publication.trackSid}`);
                if (audioElement) {
                    audioElement.remove();
                    console.log(`Detached audio track for ${participant.identity}, trackSid: ${publication.trackSid}`);
                }
            });
        };

        // Subscribe to and attach existing tracks
        const subscribeToExistingTracks = () => {
            if (room && room.state === 'connected') {
                console.log('Checking existing participants for tracks...');
                const participants = (room.getParticipants && room.getParticipants()) || (room.participants ? Array.from(room.participants.values()) : []);
                console.log('Participants found:', participants.map(p => p.identity));
                participants.forEach(participant => {
                    console.log(`Processing existing participant: ${participant.identity}, SID: ${participant.sid}`);
                    const tracks = participant.getTrackPublications ? Array.from(participant.getTrackPublications()) : [];
                    tracks.forEach(publication => {
                        if (publication.kind === 'audio') {
                            console.log(`Found track for ${participant.identity}, trackSid: ${publication.trackSid}, isSubscribed: ${publication.isSubscribed}, isMuted: ${publication.isMuted}`);
                            if (publication.track && !publication.isSubscribed) {
                                console.log(`Subscribing to track for ${participant.identity}, trackSid: ${publication.trackSid}`);
                                publication.setSubscribed(true);
                            }
                            attachAudioTracks(participant);
                        }
                    });
                    if (tracks.length === 0) {
                        console.log(`No audio tracks for ${participant.identity}`);
                    }
                });
            } else {
                console.log('Room not connected or no participants, state:', room ? room.state : 'no room');
            }
        };

        async function joinRoom() {
            try {
                const roomName = document.getElementById('roomName').value;
                const participantName = document.getElementById('participantName').value;
                const response = await fetch(`/get-token/?room=${roomName}&participant=${participantName}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch token: ${response.statusText}`);
                }
                const data = await response.json();

                room = new LivekitClient.Room();
                console.log('Connecting to:', data.livekit_url, 'with token:', data.token.substring(0, 10) + '...');
                await room.connect(data.livekit_url, data.token, {
                    audio: true,
                    video: false,
                    autoSubscribe: true
                });
                console.log('Connected to room:', room.name, 'SID:', room.sid, 'State:', room.state, 'Participants:', (room.getParticipants && room.getParticipants().map(p => p.identity)) || 'none');

                // Publish local audio track
                await room.localParticipant.setMicrophoneEnabled(true);
                const localTracks = room.localParticipant.getTrackPublications ? Array.from(room.localParticipant.getTrackPublications()) : [];
                console.log('Local audio track published for', room.localParticipant.identity, 'Tracks:', localTracks.map(t => t.trackSid));

                // Update UI with room name
                document.getElementById('active-room').innerText = room.name;

                // Handle existing participants and their tracks
                if (room.state === 'connected') {
                    subscribeToExistingTracks();
                }
                updateParticipants();

                // Aggressive retries for track subscription
                const retryIntervals = [500, 1000, 2000, 4000, 6000, 10000, 15000, 20000];
                retryIntervals.forEach(interval => setTimeout(subscribeToExistingTracks, interval));

                // Handle new participants
                room.on('participantConnected', participant => {
                    console.log('Participant connected:', participant.identity, 'SID:', participant.sid);
                    attachAudioTracks(participant);
                    updateParticipants();
                    setTimeout(subscribeToExistingTracks, 500); // Re-check tracks
                    setTimeout(subscribeToExistingTracks, 1000); // Additional check
                });

                // Handle active participants changed
                room.on('activeParticipantsChanged', participants => {
                    console.log('Active participants changed:', participants.map(p => p.identity));
                    participants.forEach(participant => attachAudioTracks(participant));
                    updateParticipants();
                    setTimeout(subscribeToExistingTracks, 500); // Re-check tracks
                });

                // Handle participant metadata changes
                room.on('participantMetadataChanged', participant => {
                    console.log('Participant metadata changed:', participant.identity, 'SID:', participant.sid);
                    attachAudioTracks(participant);
                    updateParticipants();
                    setTimeout(subscribeToExistingTracks, 500); // Re-check tracks
                });

                // Handle room metadata changes
                room.on('roomMetadataChanged', () => {
                    console.log('Room metadata changed, re-checking participants...');
                    subscribeToExistingTracks();
                });

                // Handle participant disconnections
                room.on('participantDisconnected', participant => {
                    console.log('Participant disconnected:', participant.identity, 'SID:', participant.sid);
                    detachAudioTracks(participant);
                    updateParticipants();
                });

                // Handle track subscriptions
                room.on('trackSubscribed', (track, publication, participant) => {
                    if (publication.kind === 'audio') {
                        const audioElement = track.attach();
                        audioElement.id = `audio-${participant.sid}-${publication.trackSid}`;
                        document.getElementById('audio-container').appendChild(audioElement);
                        audioElement.play().catch(err => console.error(`Failed to play audio for ${participant.identity}, trackSid: ${publication.trackSid}:`, err));
                        console.log(`Subscribed to audio track from ${participant.identity}, trackSid: ${publication.trackSid}`);
                        updateParticipants();
                    }
                });

                // Handle track publications
                room.on('trackPublished', (publication, participant) => {
                    if (publication.kind === 'audio') {
                        console.log('Track published by', participant.identity, 'trackSid:', publication.trackSid, 'subscribing...');
                        if (!publication.isSubscribed) {
                            publication.setSubscribed(true);
                        }
                    }
                });

                // Handle track stream started
                room.on('trackStreamStarted', (track, publication, participant) => {
                    if (publication.kind === 'audio') {
                        console.log(`Track stream started for ${participant.identity}, trackSid: ${publication.trackSid}`);
                        attachAudioTracks(participant);
                    }
                });

                // Handle track unsubscriptions
                room.on('trackUnsubscribed', (track, publication, participant) => {
                    if (publication.kind === 'audio') {
                        const audioElement = document.getElementById(`audio-${participant.sid}-${publication.trackSid}`);
                        if (audioElement) {
                            audioElement.remove();
                            console.log(`Unsubscribed from audio track of ${participant.identity}, trackSid: ${publication.trackSid}`);
                        }
                        updateParticipants();
                    }
                });

                // Handle track mute/unmute
                room.on('trackMuted', (publication, participant) => {
                    console.log(`${participant.identity}'s track muted, trackSid: ${publication.trackSid}`);
                    updateParticipants();
                });
                room.on('trackUnmuted', (publication, participant) => {
                    console.log(`${participant.identity}'s track unmuted, trackSid: ${publication.trackSid}`);
                    attachAudioTracks(participant);
                    updateParticipants();
                });

                // Handle local track publication
                room.on('localTrackPublished', (track, publication) => {
                    console.log(`Local track published: ${publication.kind}, trackSid: ${publication.trackSid}`);
                    updateParticipants();
                });

                // Enable mute button
                document.getElementById('muteButton').disabled = false;

                // Update button states
                document.querySelector('button[onclick="joinRoom()"]').disabled = true;
                document.querySelector('button[onclick="leaveRoom()"]').disabled = false;
            } catch (error) {
                console.error('Connection failed:', error);
                document.getElementById('error').innerText = `Error: ${error.message}`;
            }
        }

        async function leaveRoom() {
            try {
                if (room) {
                    await room.disconnect();
                    document.getElementById('audio-container').innerHTML = '';
                    document.getElementById('active-room').innerText = 'None';
                    document.getElementById('participants').innerHTML = '';
                    document.querySelector('button[onclick="joinRoom()"]').disabled = false;
                    document.querySelector('button[onclick="leaveRoom()"]').disabled = true;
                    document.getElementById('muteButton').disabled = true;
                    document.getElementById('muteButton').innerText = 'Mute';
                    room = null;
                    isMuted = false;
                }
            } catch (error) {
                console.error('Disconnect failed:', error);
                document.getElementById('error').innerText = `Error: ${error.message}`;
            }
        }

        async function toggleMute() {
            try {
                if (!room) return;
                isMuted = !isMuted;
                await room.localParticipant.setMicrophoneEnabled(!isMuted);
                document.getElementById('muteButton').innerText = isMuted ? 'Unmute' : 'Mute';
                document.getElementById('error').innerText = '';
                updateParticipants();
            } catch (error) {
                console.error('Mute toggle failed:', error);
                document.getElementById('error').innerText = `Error: ${error.message}`;
            }
        }
    </script>
</body>
</html>